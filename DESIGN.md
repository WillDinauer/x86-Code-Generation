#
# DESIGN.md - Design spec for Project 3: Code Generation
#
# William Dinauer, Dartmouth CS57 Spring 2022

### Design Overview

In conjunction, the codegen.cpp, x86.cpp, and x86.hpp files will convert IR code into x86 assembly.
The design is built around the skeleton created by Ben Kallus, the TA for the course.
The program is constructed as an LLVM pass, which makes it easier to handle the different potential IR instructions.

The skeleton code provided by Ben handles branches, call, return, and the beginning of blocks (giving them an x86 label).
In order to complete the project, I designed code for handling binary operators (add, subtract, multiply, divide), and icmp instructions.
Note that our design assumes that we only have programs with types integer and void.

    The *handle_binop* function is inteded to convert binary insructions into x86 assembly code. 
The function takes two parameters: an LLVM iterator for the BasicBlock we're currently in (which we
will cast to the proper instruction type), and a string for the operator type ('add', 'sub', 'mul', or 'div'). 
We assume that stomping on the %rax register is completely fine as it will eventually hold the 
return value of the program and will be properly updated before the program terminates. 
    To begin, we cast the BasicBlock iterator to an llvm BinaryOperator. Then, we grab the 
left and right operator for the binary instruction and set up an x86Source for each (initially set tonullptr). 
First we check the left operator. If the left operator is a constant, we cast it to an x86Immediate
and save it as the left source. Otherwise, the left operator was saved to a register in a previous
instruction, so we grab the proper register using the *query_slot* command, designed by Ben. 
We will insert a new instruction to 'movq' the left source into %rax. 
    We perform the same process with the right operand to tell whether the right source should be an
x86Immediate or an x86Register. Then, we insert a command based on the operation. If we are
performing an 'add' or 'sub', our instruction begins with the operation ('add' or 'sub') followed by 
the right source, followed by %rax. If we are performing a 'mul' or 'div', our instruction begins
with the operation ('mul' or 'div') followed by the rights source. Note that 'mul' and 'div' will
implicitly apply their operations to %rax. Since we previously saved the left source in %rax, 
our inserted instructions perform the the equivalent of applying the operation between the left 
source and right source and storing the result in %rax.
    Finally, we only insert the instruction to save the result stored in %rax to a new register only if
there are future uses of this instruction (otherwise it is a waste of memory).

    The *handle_icmp* function operates in a very similar way to *handle_binop*. In this case,
we only pass the BasicBlock iterator, then cast the iterator to an LLVM CmpInst.
Once again, we grab the left and right operands for the comparison, and setup left and right
sources which are initially nullptrs. Starting with the left operator, if the operator is a constant,
we save the left source as an x86Immediate. Otherwise, we find the x86Register associated with the
previous instruction and set it to the left source. We insert a 'movq' instruction, with the left
source as the source and %rax as the destination. Then, we check whether the right source should
be an x86Immediate or an x86Register. Finally, we insert the 'cmp' instruction, with the right
source as the source and %rax as the destination. Note that the 'cmp' instruction will set the flags
in x86 that will be used to check the jump conditions for branching.

### Usage

To run the code, there are two options.

The first option is to run the command:  ./fullpipeline.sh [filename]
Where the filename is an IR file, usually denoted by the .ll suffix and often generated by clang.
This will both convert the IR to x86 assembly, and will print the output of running the generated assembly code.

The second option is to first the command: make
This will compile the codegen executable.
You can then run: ./codegen [filename]
Again, the filename is an IR file. This will simply output the generated x86 code.

To clean up the directory when finished, run 'make clean'
